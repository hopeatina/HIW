'use strict';var lang_1 = require('angular2/src/facade/lang');
var collection_1 = require('angular2/src/facade/collection');
// `context` is always the first field.
var _CONTEXT_IDX = 0;
var _whiteSpaceRegExp = lang_1.RegExpWrapper.create("\\W", "g");
/**
 * Returns `s` with all non-identifier characters removed.
 */
function sanitizeName(s) {
    return lang_1.StringWrapper.replaceAll(s, _whiteSpaceRegExp, '');
}
exports.sanitizeName = sanitizeName;
/**
 * Class responsible for providing field and local variable names for change detector classes.
 * Also provides some convenience functions, for example, declaring variables, destroying pipes,
 * and dehydrating the detector.
 */
var CodegenNameUtil = (function () {
    function CodegenNameUtil(records, directiveRecords, fieldPrefix, utilName) {
        this.records = records;
        this.directiveRecords = directiveRecords;
        this.fieldPrefix = fieldPrefix;
        this.utilName = utilName;
        this._sanitizedNames = collection_1.ListWrapper.createFixedSize(this.records.length + 1);
        this._sanitizedNames[_CONTEXT_IDX] = 'context';
        for (var i = 0, iLen = this.records.length; i < iLen; ++i) {
            this._sanitizedNames[i + 1] = sanitizeName("" + this.records[i].name + i);
        }
    }
    CodegenNameUtil.prototype.getContextName = function () { return this.getFieldName(_CONTEXT_IDX); };
    CodegenNameUtil.prototype.getLocalName = function (idx) { return this._sanitizedNames[idx]; };
    CodegenNameUtil.prototype.getChangeName = function (idx) { return "c_" + this._sanitizedNames[idx]; };
    /**
     * Generate a statement initializing local variables used when detecting changes.
     */
    CodegenNameUtil.prototype.genInitLocals = function () {
        var declarations = [];
        var assignments = [];
        for (var i = 0, iLen = this.getFieldCount(); i < iLen; ++i) {
            var changeName = this.getChangeName(i);
            declarations.push(this.getLocalName(i) + "," + changeName);
            assignments.push(changeName);
        }
        return ("var " + collection_1.ListWrapper.join(declarations, ',') + ";") +
            (collection_1.ListWrapper.join(assignments, '=') + " = false;");
    };
    CodegenNameUtil.prototype.getFieldCount = function () { return this._sanitizedNames.length; };
    CodegenNameUtil.prototype.getFieldName = function (idx) { return "" + this.fieldPrefix + this._sanitizedNames[idx]; };
    CodegenNameUtil.prototype.getAllFieldNames = function () {
        var fieldList = [];
        for (var k = 0, kLen = this.getFieldCount(); k < kLen; ++k) {
            fieldList.push(this.getFieldName(k));
        }
        for (var i = 0, iLen = this.records.length; i < iLen; ++i) {
            var rec = this.records[i];
            if (rec.isPipeRecord()) {
                fieldList.push(this.getPipeName(rec.selfIndex));
            }
        }
        for (var j = 0, jLen = this.directiveRecords.length; j < jLen; ++j) {
            var dRec = this.directiveRecords[j];
            fieldList.push(this.getDirectiveName(dRec.directiveIndex));
            if (dRec.isOnPushChangeDetection()) {
                fieldList.push(this.getDetectorName(dRec.directiveIndex));
            }
        }
        return fieldList;
    };
    /**
     * Generates a statement which declares all fields.
     * This is only necessary for Dart change detectors.
     */
    CodegenNameUtil.prototype.genDeclareFields = function () {
        var fields = this.getAllFieldNames();
        collection_1.ListWrapper.removeAt(fields, _CONTEXT_IDX);
        return collection_1.ListWrapper.isEmpty(fields) ? '' : "var " + collection_1.ListWrapper.join(fields, ', ') + ";";
    };
    /**
     * Generates statements which clear all fields so that the change detector is dehydrated.
     */
    CodegenNameUtil.prototype.genDehydrateFields = function () {
        var fields = this.getAllFieldNames();
        collection_1.ListWrapper.removeAt(fields, _CONTEXT_IDX);
        if (!collection_1.ListWrapper.isEmpty(fields)) {
            // At least one assignment.
            fields.push(this.utilName + ".uninitialized;");
        }
        return this.getContextName() + " = null; " + collection_1.ListWrapper.join(fields, ' = ');
    };
    /**
     * Generates statements destroying all pipe variables.
     */
    CodegenNameUtil.prototype.genPipeOnDestroy = function () {
        var _this = this;
        return collection_1.ListWrapper.join(collection_1.ListWrapper.map(collection_1.ListWrapper.filter(this.records, function (r) {
            return r.isPipeRecord();
        }), function (r) { return _this.getPipeName(r.selfIndex) + ".onDestroy();"; }), '\n');
    };
    CodegenNameUtil.prototype.getPipeName = function (idx) { return "" + this.fieldPrefix + this._sanitizedNames[idx] + "_pipe"; };
    CodegenNameUtil.prototype.getAllDirectiveNames = function () {
        var _this = this;
        return collection_1.ListWrapper.map(this.directiveRecords, function (d) { return _this.getDirectiveName(d.directiveIndex); });
    };
    CodegenNameUtil.prototype.getDirectiveName = function (d) { return this.fieldPrefix + "directive_" + d.name; };
    CodegenNameUtil.prototype.getAllDetectorNames = function () {
        var _this = this;
        return collection_1.ListWrapper.map(collection_1.ListWrapper.filter(this.directiveRecords, function (r) { return r.isOnPushChangeDetection(); }), function (d) { return _this.getDetectorName(d.directiveIndex); });
    };
    CodegenNameUtil.prototype.getDetectorName = function (d) { return this.fieldPrefix + "detector_" + d.name; };
    return CodegenNameUtil;
})();
exports.CodegenNameUtil = CodegenNameUtil;
//# sourceMappingURL=codegen_name_util.js.map